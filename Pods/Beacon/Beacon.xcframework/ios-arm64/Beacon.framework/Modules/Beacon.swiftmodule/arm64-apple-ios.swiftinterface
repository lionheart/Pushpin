// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.3.1 (swiftlang-1200.0.41 clang-1200.0.32.8)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Beacon
@_exported import Beacon
import CommonCrypto
import CoreData
import CoreFoundation
import Foundation
import ImageIO
import MobileCoreServices
import Beacon.Private
import QuickLook
import Security
import Swift
import SystemConfiguration
import UIKit
import zlib
public class Animator {
  public init(withDelegate delegate: Beacon.GIFAnimatable)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc(HSBeaconArticleEscalationViewController) public class BeaconArticleEscalationViewController : UIKit.UIViewController {
  @objc public init(stringLocalizer: Beacon.HSBeaconStringLocalizer, settings: Beacon.HSBeaconSettings, tintColorSettings: Beacon.HSBeaconTintColor, actionColor: UIKit.UIColor, messagingEnabled: Swift.Bool)
  @objc override dynamic public func viewDidLoad()
  @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
}
@objc(HSBeaconArticleRating) public enum BeaconArticleRating : Swift.UInt {
  case positive
  case negative
  public typealias RawValue = Swift.UInt
  public init?(rawValue: Swift.UInt)
  public var rawValue: Swift.UInt {
    get
  }
}
@objc(HSBeaconArticleRatingViewDelegate) public protocol BeaconArticleRatingViewDelegate : AnyObject {
  @objc func articleRatingView(_ view: Beacon.BeaconArticleRatingView, ratedArticle rating: Beacon.BeaconArticleRating)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(HSBeaconArticleRatingView) public class BeaconArticleRatingView : UIKit.UIView {
  @objc public static var contentHeight: CoreGraphics.CGFloat
  @objc weak public var delegate: Beacon.BeaconArticleRatingViewDelegate?
  @objc public var stringLocalizer: Beacon.HSBeaconStringLocalizer? {
    @objc get
    @objc set
  }
  @objc deinit
}
public enum BeaconRoute {
  case home
  case ask
  case askMessage
  case askChat
  case answers
  case previousMessages
  case search(Swift.String)
  case article(Swift.String)
  public var route: Swift.String {
    get
  }
}
extension HSBeacon {
  public class func navigate(_ route: Beacon.BeaconRoute, settings: Beacon.HSBeaconSettings, viewController: UIKit.UIViewController? = nil, signature: Swift.String? = nil)
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(HSBeaconSearchPlaceholderView) public class BeaconSearchPlaceholderView : UIKit.UIView {
  @objc public func setPlaceholder(_ string: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(HSBeaconThanksFeedbackView) public class BeaconThanksFeedbackView : UIKit.UIView {
  @objc public var stringLocalizer: Beacon.HSBeaconStringLocalizer? {
    @objc get
    @objc set
  }
  @objc deinit
}
public protocol CancelableOperation {
  func cancel()
}
extension URLSessionDataTask : Beacon.CancelableOperation {
}
public typealias Reducer<Value, Action> = (inout Value, Action) -> [Beacon.Effect<Action>]
public func logging<Value, Action>(_ reducer: @escaping Beacon.Reducer<Value, Action>) -> Beacon.Reducer<Value, Action>
public func combine<State, Action>(_ reducers: Beacon.Reducer<State, Action>...) -> Beacon.Reducer<State, Action>
public struct Tagged<Tag, RawValue> {
  public var rawValue: RawValue
  public init(rawValue: RawValue)
  public func map<B>(_ f: (RawValue) -> B) -> Beacon.Tagged<Tag, B>
}
extension Tagged : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Tagged : Swift.RawRepresentable {
}
extension Tagged : Swift.Equatable where RawValue : Swift.Equatable {
}
extension Tagged : Swift.ExpressibleByExtendedGraphemeClusterLiteral where RawValue : Swift.ExpressibleByExtendedGraphemeClusterLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = RawValue.ExtendedGraphemeClusterLiteralType
  public init(extendedGraphemeClusterLiteral: Beacon.Tagged<Tag, RawValue>.ExtendedGraphemeClusterLiteralType)
}
extension Tagged : Swift.ExpressibleByStringLiteral where RawValue : Swift.ExpressibleByStringLiteral {
  public typealias StringLiteralType = RawValue.StringLiteralType
  public init(stringLiteral: Beacon.Tagged<Tag, RawValue>.StringLiteralType)
}
extension Tagged : Swift.ExpressibleByUnicodeScalarLiteral where RawValue : Swift.ExpressibleByUnicodeScalarLiteral {
  public typealias UnicodeScalarLiteralType = RawValue.UnicodeScalarLiteralType
  public init(unicodeScalarLiteral: Beacon.Tagged<Tag, RawValue>.UnicodeScalarLiteralType)
}
extension Tagged : Swift.Decodable where RawValue : Swift.Decodable {
  public init(from decoder: Swift.Decoder) throws
}
extension Tagged : Swift.Encodable where RawValue : Swift.Encodable {
  public func encode(to encoder: Swift.Encoder) throws
}
@objc @_inheritsConvenienceInitializers public class ChatDependencies : ObjectiveC.NSObject {
  @objc public class func setTintColorSettings(_ tintColor: Beacon.HSBeaconTintColor)
  @objc public class func setStringLocalizer(_ stringLocalizer: Beacon.HSBeaconStringLocalizer)
  @objc public class func setBeaconConfig(_ config: Beacon.HSBeaconConfig)
  @objc public class func setBeaconID(_ beaconID: Swift.String)
  @objc public class func setDeviceID(_ deviceID: Swift.String)
  @objc public class func setSignature(_ signature: Swift.String?)
  @objc public class func setSignatureVerified(_ verified: Swift.Bool)
  @objc public class func setChatEndedDelegate(_ delegate: Beacon.HSBeaconChatEndedDelegate?)
  @objc public class func setBeaconAgents(_ agents: [Beacon.HSBeaconAgent])
  @objc public class func setEnablePreviousMessages(_ enabled: Swift.Bool)
  @objc public class func setAttachmentsEnabled(_ enabled: Swift.Bool)
  @objc public class func setPushNotificationSupport(_ support: Beacon.HSBeaconPushNotificationSupport)
  @objc public class func hasPausedChat() -> Swift.Bool
  @objc public class func chatViewControllerClass() -> Swift.AnyClass
  @objc public class func endChat()
  @objc public class func didChatGenerateConversationWithId(_ id: Swift.String) -> Swift.Bool
  @objc public class func setRequiresEmail(_ requiresEmail: Swift.Bool)
  @objc public class func setRatingsEnabled(_ enabled: Swift.Bool)
  @objc public class func setBeaconDelegate(_ delegate: Beacon.HSBeaconDelegate)
  @objc public class func setActionColor(_ color: UIKit.UIColor)
  @objc deinit
  @objc override dynamic public init()
}
public func decode<A>(_ data: Foundation.Data) -> Swift.Result<A, Swift.DecodingError> where A : Swift.Decodable
public func decode<A>(_ data: Foundation.Data, with decoder: Foundation.JSONDecoder) -> Swift.Result<A, Swift.DecodingError> where A : Swift.Decodable
public struct Effect<A> {
  public let run: (@escaping (A) -> Swift.Void) -> Swift.Void
  public init(run: @escaping (@escaping (A) -> Swift.Void) -> Swift.Void)
  public func map<B>(_ f: @escaping (A) -> B) -> Beacon.Effect<B>
}
public protocol GIFAnimatable : AnyObject {
  var animator: Beacon.Animator? { get set }
  var layer: QuartzCore.CALayer { get }
  var frame: CoreGraphics.CGRect { get set }
  var contentMode: UIKit.UIView.ContentMode { get set }
}
public protocol ImageContainer {
  var image: UIKit.UIImage? { get set }
}
extension GIFAnimatable where Self : Beacon.ImageContainer {
  public var intrinsicContentSize: CoreGraphics.CGSize {
    get
  }
}
extension GIFAnimatable {
  public var gifLoopDuration: Foundation.TimeInterval {
    get
  }
  public var activeFrame: UIKit.UIImage? {
    get
  }
  public var frameCount: Swift.Int {
    get
  }
  public var isAnimatingGIF: Swift.Bool {
    get
  }
  public func animate(withGIFNamed imageName: Swift.String, loopCount: Swift.Int = 0, preparationBlock: (() -> Swift.Void)? = nil, animationBlock: (() -> Swift.Void)? = nil)
  public func animate(withGIFData imageData: Foundation.Data, loopCount: Swift.Int = 0, preparationBlock: (() -> Swift.Void)? = nil, animationBlock: (() -> Swift.Void)? = nil)
  public func animate(withGIFURL imageURL: Foundation.URL, loopCount: Swift.Int = 0, preparationBlock: (() -> Swift.Void)? = nil, animationBlock: (() -> Swift.Void)? = nil)
  public func prepareForAnimation(withGIFNamed imageName: Swift.String, loopCount: Swift.Int = 0, completionHandler: (() -> Swift.Void)? = nil)
  public func prepareForAnimation(withGIFData imageData: Foundation.Data, loopCount: Swift.Int = 0, completionHandler: (() -> Swift.Void)? = nil)
  public func prepareForAnimation(withGIFURL imageURL: Foundation.URL, loopCount: Swift.Int = 0, completionHandler: (() -> Swift.Void)? = nil)
  public func prepareForReuse()
  public func startAnimatingGIF()
  public func stopAnimatingGIF()
  public func setShouldResizeFrames(_ resize: Swift.Bool)
  public func setFrameBufferCount(_ frames: Swift.Int)
  public func updateImageIfNeeded()
}
@objc @_inheritsConvenienceInitializers public class GIFImageView : UIKit.UIImageView, Beacon.GIFAnimatable {
  public var animator: Beacon.Animator? {
    get
    set
  }
  @objc override dynamic public func display(_ layer: QuartzCore.CALayer)
  @objc override dynamic public init(image: UIKit.UIImage?)
  @available(iOS 3.0, *)
  @objc override dynamic public init(image: UIKit.UIImage?, highlightedImage: UIKit.UIImage?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc extension NSNotification {
  @objc public static var beaconUnreadCountDidChangeNotification: Foundation.NSString {
    @objc get
  }
  @objc public static var beaconOpenedNotification: Foundation.NSString {
    @objc get
  }
}
@objc public enum HSBeaconRoute : Swift.Int, Swift.RawRepresentable {
  case home
  case ask
  case askMessage
  case askChat
  case answers
  case previousMessages
  case search
  case article
  case unknown
  public var stringValue: Swift.String {
    get
  }
  public init(navString: Swift.String)
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class HSBeaconRouting : ObjectiveC.NSObject {
  @objc final public let route: Beacon.HSBeaconRoute
  @objc public var fulfilled: Swift.Bool
  @objc public var animated: Swift.Bool
  @objc public var articleId: Swift.String {
    @objc get
  }
  @objc public var searchQuery: Swift.String {
    @objc get
  }
  @objc public init(navigation: Swift.String)
  @objc public init(articleId: Swift.String)
  @objc public init(searchText: Swift.String)
  @objc public init(route: Beacon.HSBeaconRoute, routeData: Swift.String? = nil)
  @objc public func isValidWith(docsEnabled: Swift.Bool, messagingEnabled: Swift.Bool, chatEnabled: Swift.Bool, previousMessagesEnabled: Swift.Bool) -> Swift.Bool
  @objc public func invalidRouteMessage(stringLocalizer: Beacon.HSBeaconStringLocalizer) -> Swift.String
  @objc deinit
  @objc override dynamic public init()
}
@objc @_inheritsConvenienceInitializers public class HSBeaconUnreadMessageCountGenerator : ObjectiveC.NSObject {
  @objc public class func unreadMessageCount(with previousMessages: [Beacon.HSBeaconConversation]) -> Swift.Int
  @objc deinit
  @objc override dynamic public init()
}
@objc public protocol HSEnterEmailViewControllerDelegate {
  @objc func enterEmailController(_ controller: Beacon.HSEnterEmailViewController, didEnter email: Swift.String)
}
@_inheritsConvenienceInitializers @objc public class HSEnterEmailViewController : UIKit.UIViewController {
  @objc weak public var delegate: Beacon.HSEnterEmailViewControllerDelegate?
  @objc public static func instantiateViewController() -> Beacon.HSEnterEmailViewController
  @objc override dynamic public func viewDidLoad()
  @objc deinit
  @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
}
public enum HTTPMethod : Swift.Equatable {
  case options
  case get
  case head
  case post(Foundation.Data?)
  case put(Foundation.Data?)
  case patch(Foundation.Data?)
  case delete
  case trace
  case connect
  public var body: Foundation.Data? {
    get
  }
  public var rawValue: Swift.String {
    get
  }
  public static func == (a: Beacon.HTTPMethod, b: Beacon.HTTPMethod) -> Swift.Bool
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc(HSBeaconLoadingView) public class LoadingView : UIKit.UIView {
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
@available(*, unavailable, renamed: "Notification.Name.reachabilityChanged")
public let ReachabilityChangedNotification: Foundation.NSNotification.Name
extension NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class Reachability {
  public typealias NetworkReachable = (Beacon.Reachability) -> ()
  public typealias NetworkUnreachable = (Beacon.Reachability) -> ()
  public enum Connection : Swift.CustomStringConvertible {
    case none
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: Beacon.Reachability.Connection, b: Beacon.Reachability.Connection) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
    public func hash(into hasher: inout Swift.Hasher)
  }
  public var whenReachable: Beacon.Reachability.NetworkReachable?
  public var whenUnreachable: Beacon.Reachability.NetworkUnreachable?
  @available(*, deprecated, renamed: "allowsCellularConnection")
  final public let reachableOnWWAN: Swift.Bool
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  @available(*, deprecated, renamed: "connection.description")
  public var currentReachabilityString: Swift.String {
    get
  }
  @available(*, unavailable, renamed: "connection")
  public var currentReachabilityStatus: Beacon.Reachability.Connection {
    get
  }
  public var connection: Beacon.Reachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension Reachability {
  public func startNotifier() throws
  public func stopNotifier()
  @available(*, deprecated, message: "Please use `connection != .none`")
  public var isReachable: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .cellular`")
  public var isReachableViaWWAN: Swift.Bool {
    get
  }
  @available(*, deprecated, message: "Please use `connection == .wifi`")
  public var isReachableViaWiFi: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : Beacon.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [Beacon.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
@objc extension UIColor {
  @objc public static func beaconBackground() -> UIKit.UIColor
  @objc public static func secondaryBeaconBackground() -> UIKit.UIColor
  @objc public static func tertiaryBeaconBackground() -> UIKit.UIColor
  @objc public static func disabledAction() -> UIKit.UIColor
  @objc public static func primaryText() -> UIKit.UIColor
  @objc public static func primaryAccent() -> UIKit.UIColor
  @objc public static func chatBubbleText() -> UIKit.UIColor
  @objc public static func chatBorder() -> UIKit.UIColor
  @objc public static func chatErrorBorder() -> UIKit.UIColor
  @objc public static func brightOrange() -> UIKit.UIColor
  @objc public static func chatErrorBackground() -> UIKit.UIColor
  @objc public static func agentAvatarBackground() -> UIKit.UIColor
  @objc public static func agentTextColor() -> UIKit.UIColor
  @objc public static func unfurledMediaBodyColor() -> UIKit.UIColor
  @objc public static func chatProgressColor() -> UIKit.UIColor
  @objc public static func grey400() -> UIKit.UIColor
  @objc public static func grey500() -> UIKit.UIColor
  @objc public static func placeholderText() -> UIKit.UIColor
  @objc public static func toolbarButton() -> UIKit.UIColor
  @objc public static func borderButton() -> UIKit.UIColor
  @objc public static func yellow800() -> UIKit.UIColor
  @objc public static func escalationThanksBackground() -> UIKit.UIColor
  @objc public static func green600() -> UIKit.UIColor
  @objc public static func hsTertiaryText() -> UIKit.UIColor
  @objc public static func primaryAction() -> UIKit.UIColor
  @objc public static func hsSecondaryText() -> UIKit.UIColor
  @objc public static func badge() -> UIKit.UIColor
  @objc public static func goodGlow() -> UIKit.UIColor
  @objc public static func badGlow() -> UIKit.UIColor
  @objc public static func neutralGlow() -> UIKit.UIColor
  @objc public static func defaultBeacon() -> UIKit.UIColor
  @objc public static func lightBeacon() -> UIKit.UIColor
  @objc dynamic public func exceedsMinimumContrast(with color: UIKit.UIColor) -> Swift.Bool
  @objc dynamic public func contrasting(_ color: UIKit.UIColor) -> UIKit.UIColor
}
extension UIImageView : Beacon.ImageContainer {
}
extension UINavigationController {
  @objc dynamic public func pushViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc dynamic public func popToRootViewControllerAnimated(_ animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc dynamic public func popToRootViewControllerAnimated(_ animated: Swift.Bool, completedToRootVC: ((UIKit.UIViewController?) -> Swift.Void)?)
  @objc dynamic public func popToViewController(_ viewController: UIKit.UIViewController, animated: Swift.Bool, completion: ((Swift.Bool) -> Swift.Void)?)
  @objc dynamic public func configure(with tintColorSettings: Beacon.HSBeaconTintColor)
  public func perform(_ action: () -> (), animated: Swift.Bool, with completion: ((Swift.Bool) -> Swift.Void)?)
}
extension UITraitCollection {
  @objc dynamic public var isRegularRegular: Swift.Bool {
    @objc get
  }
  @objc dynamic public func hasDifferentSizeClass(comparedTo traitCollection: UIKit.UITraitCollection?) -> Swift.Bool
}
@objc extension UIWindow {
  @objc dynamic public var topViewController: UIKit.UIViewController? {
    @objc get
  }
}
@_inheritsConvenienceInitializers @objc(HSBeaconViewControllerFactory) public class ViewControllerFactory : ObjectiveC.NSObject {
  @objc public class func articleViewController() -> Beacon.HSBeaconArticleViewController
  @objc public class func askSelectionViewController() -> Beacon.HSBeaconAskSelectionController
  @objc public class func chatViewController() -> UIKit.UIViewController
  @objc public class func messageEntryViewController() -> Beacon.HSBeaconMessageEntryContainerController
  @objc public class func previousMessagesViewController() -> Beacon.HSBeaconPreviousMessagesController
  @objc deinit
  @objc override dynamic public init()
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public typealias RawValue = Swift.UInt16
  public init?(rawValue: Swift.UInt16)
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: Beacon.ErrorType, b: Beacon.ErrorType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct WSError : Swift.Error {
  public let type: Beacon.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: Beacon.WebSocketDelegate? { get set }
  var pongDelegate: Beacon.WebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: Beacon.SSLClientCertificate? { get set }
  var security: Beacon.SSLTrustValidator? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: Beacon.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: Swift.Error?)
}
public protocol WSStream {
  var delegate: Beacon.WSStreamDelegate? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Beacon.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, Beacon.WSStream, Foundation.StreamDelegate {
  weak public var delegate: Beacon.WSStreamDelegate?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: Beacon.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc deinit
  @objc override dynamic public init()
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: Beacon.WebSocketClient)
  func websocketDidDisconnect(socket: Beacon.WebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Beacon.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: Beacon.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: Beacon.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: Beacon.WebSocket)
  func websocketDidDisconnect(socket: Beacon.WebSocket, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: Beacon.WebSocket, text: Swift.String, response: Beacon.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: Beacon.WebSocket, data: Foundation.Data, response: Beacon.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: Beacon.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: Beacon.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, Beacon.WebSocketClient, Beacon.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: Beacon.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: Beacon.WebSocketDelegate?
  weak public var advancedDelegate: Beacon.WebSocketAdvancedDelegate?
  weak public var pongDelegate: Beacon.WebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Swift.Error?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: Beacon.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: Beacon.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: Beacon.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: Swift.Error?)
  @objc deinit
  @objc override dynamic public init()
}
extension Beacon.BeaconArticleRating : Swift.Equatable {}
extension Beacon.BeaconArticleRating : Swift.Hashable {}
extension Beacon.BeaconArticleRating : Swift.RawRepresentable {}
extension Beacon.HSBeaconRoute : Swift.Equatable {}
extension Beacon.HSBeaconRoute : Swift.Hashable {}
extension Beacon.Reachability.Connection : Swift.Equatable {}
extension Beacon.Reachability.Connection : Swift.Hashable {}
extension Beacon.CloseCode : Swift.Equatable {}
extension Beacon.CloseCode : Swift.Hashable {}
extension Beacon.CloseCode : Swift.RawRepresentable {}
extension Beacon.ErrorType : Swift.Equatable {}
extension Beacon.ErrorType : Swift.Hashable {}
extension Beacon.WebSocket.OpCode : Swift.Equatable {}
extension Beacon.WebSocket.OpCode : Swift.Hashable {}
extension Beacon.WebSocket.OpCode : Swift.RawRepresentable {}

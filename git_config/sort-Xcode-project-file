#!/usr/bin/perl -w

# Copyright (C) 2007, 2008, 2009, 2010 Apple Inc.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer. 
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution. 
# 3.  Neither the name of Apple Inc. ("Apple") nor the names of
#     its contributors may be used to endorse or promote products derived
#     from this software without specific prior written permission. 
#
# THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# Script to sort "children" and "files" sections in Xcode project.pbxproj files

use strict;

use File::Basename;
use File::Spec;
use File::Temp qw(tempfile);
use Getopt::Long;
use IO::Scalar;

sub sortChildrenByFileName($$);
sub sortFilesByFileName($$);

# Files (or products) without extensions
my %isFile = map { $_ => 1 } qw(
    create_hash_table
    jsc
    minidom
    testapi
    testjsglue
);

my $printWarnings = 1;
my $showHelp;

my $getOptionsResult = GetOptions(
    'h|help'         => \$showHelp,
    'w|warnings!'    => \$printWarnings,
);

if (!$getOptionsResult || $showHelp) {
    print STDERR <<__END__;
Usage: @{[ basename($0) ]} [options] STDIN
  -h|--help           show this help message
  -w|--[no-]warnings  show or suppress warnings (default: show warnings)
__END__
    exit 1;
}

# See http://www.perlmonks.org/?node_id=33587
my $INPUTDATA = join '', <STDIN>;
my $s;
tie *STDIN, 'IO::Scalar', \$s;
print STDIN $INPUTDATA;
tied(*STDIN)->setpos(0);

my $mainGroup = "";
my $line = "";
foreach $line (split /\n/, $INPUTDATA) {
    $mainGroup = $2 if $line =~ m#^(\s*)mainGroup = ([0-9A-F]{24}( /\* .+ \*/)?);$#;
}

my @lastTwo = ();
while (my $line = <STDIN>) {
    if ($line =~ /^(\s*)files = \(\s*$/) {
        print $line;
        my $endMarker = $1 . ");";
        my @files;
        while (my $fileLine = <STDIN>) {
            if ($fileLine =~ /^\Q$endMarker\E\s*$/) {
                $endMarker = $fileLine;
                last;
            }
            push @files, $fileLine;
        }
        print sort sortFilesByFileName @files;
        print $endMarker;
    } elsif ($line =~ /^(\s*)children = \(\s*$/) {
        print $line;
        my $endMarker = $1 . ");";
        my @children;
        while (my $childLine = <STDIN>) {
            if ($childLine =~ /^\Q$endMarker\E\s*$/) {
                $endMarker = $childLine;
                last;
            }
            push @children, $childLine;
        }
        if ($lastTwo[0] =~ m#^\s+\Q$mainGroup\E = \{$#) {
            # Don't sort mainGroup
            print @children;
        } else {
            print sort sortChildrenByFileName @children;
        }
        print $endMarker;
    } else {
        print $line;
    }

    push @lastTwo, $line;
    shift @lastTwo if scalar(@lastTwo) > 2;
}

exit 0;

sub sortChildrenByFileName($$)
{
    my ($a, $b) = @_;
    my $aFileName = $1 if $a =~ /^\s*[A-Z0-9]{24} \/\* (.+) \*\/,$/;
    my $bFileName = $1 if $b =~ /^\s*[A-Z0-9]{24} \/\* (.+) \*\/,$/;
    my $aSuffix = $1 if $aFileName =~ m/\.([^.]+)$/;
    my $bSuffix = $1 if $bFileName =~ m/\.([^.]+)$/;
    if ((!$aSuffix && !$isFile{$aFileName} && $bSuffix) || ($aSuffix && !$bSuffix && !$isFile{$bFileName})) {
        return !$aSuffix ? -1 : 1;
    }
    return lc($aFileName) cmp lc($bFileName);
}

sub sortFilesByFileName($$)
{
    my ($a, $b) = @_;
    my $aFileName = $1 if $a =~ /^\s*[A-Z0-9]{24} \/\* (.+) in /;
    my $bFileName = $1 if $b =~ /^\s*[A-Z0-9]{24} \/\* (.+) in /;
    return lc($aFileName) cmp lc($bFileName);
}
